const {
  NumericTypes,
  StringTypes,
  BigIntTypes,
  ObjectTypes,
  BooleanTypes,
  NetworkTypes
} = require('./types') // adjust path if needed

module.exports = function generateTypes(hyperschema, { filename }) {
  const structs = Array.from(hyperschema.types.values())

  let typings = ''
  typings += `// Auto-generated by hyperschema codegen\n\n`

  for (const struct of structs) {
    if (struct.isEnum) {
      typings += `export enum ${sanitize(struct.fqn)} {\n`
      for (const e of struct.enum) {
        const key = e.key.replace(/[^a-zA-Z0-9_]/g, '_')
        typings += `  ${key} = ${JSON.stringify(e.key)},\n`
      }
      typings += '}\n\n'
      continue
    }

    if (struct.isArray) {
      const typeName = sanitize(struct.fqn)
      const elementType = tsType(struct.type)
      typings += `export type ${typeName} = ${elementType}[]\n\n`
      continue
    }

    if (struct.isStruct || struct.isVersioned) {
      const typeName = sanitize(struct.fqn)
      typings += `export interface ${typeName} {\n`
      if (struct.isVersioned) typings += `  version?: number\n`

      for (const field of struct.fields || []) {
        const name = field.name
        const optional = field.required ? '' : '?'
        const safeName = quoteIfNeeded(name)
        typings += `  ${safeName}${optional}: ${tsType(field.type)}\n`
      }

      typings += '}\n\n'
    }
  }

  typings += `
export function encode<T>(name: string, value: T, v?: number): Uint8Array
export function decode<T>(name: string, buffer: Uint8Array, v?: number): T
export function getEncoding(name: string): any
export function getEnum(name: string): any
export function getStruct(name: string, v?: number): any
export function setVersion(v: number): void
export const version: number
`

  function quoteIfNeeded(name) {
    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name)) return name
    return `'${name.replace(/'/g, "\\'")}'`
  }

  function tsType(type) {
    if (!type) return 'any'

    // handle aliases
    if (type.isAlias) return tsType(type.type)

    // handle primitive
    if (type.isPrimitive) {
      const t = type.name
      if (NumericTypes.has(t)) return 'number'
      if (BigIntTypes.has(t)) return 'bigint'
      if (BooleanTypes.has(t)) return 'boolean'
      if (StringTypes.has(t)) return 'string'
      if (ObjectTypes.has(t)) {
        switch (t) {
          case 'buffer':
          case 'fixed32':
          case 'fixed64':
            return 'Uint8Array'
          case 'date':
            return 'Date'
        }
      }
      if (NetworkTypes.has(t)) return 'string'
      if (t === 'json') return 'any'
      return 'any'
    }

    // fallback to struct or user-defined type
    return sanitize(type.fqn)
  }

  function sanitize(name) {
    return name.replace(/[^\w]/g, '_')
  }

  return typings
}
