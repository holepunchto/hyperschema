const {
  NumericTypes,
  StringTypes,
  BigIntTypes,
  ObjectTypes,
  BooleanTypes,
  NetworkTypes
} = require('./types')
const generateString = require('generate-string')

module.exports = function generateTypes(hyperschema, { filename }) {
  const structsByNamespace = new Map()

  // Group structs by namespace
  for (const struct of hyperschema.types.values()) {
    const ns = struct.namespace || 'default'
    if (!structsByNamespace.has(ns)) {
      structsByNamespace.set(ns, [])
    }
    structsByNamespace.get(ns).push(struct)
  }

  let typings = ''
  typings += `// Auto-generated by hyperschema codegen\n\n`

  // Generate namespaces
  for (const [namespace, structs] of structsByNamespace.entries()) {
    typings += `export namespace ${sanitize(namespace)} {\n`

    for (const struct of structs) {
      if (struct.isEnum) {
        typings += `  export enum ${sanitize(struct.name)} {\n`
        for (const e of struct.enum) {
          const key = e.key.replace(/[^a-zA-Z0-9_]/g, '_')
          typings += `    ${sanitize(key)} = ${JSON.stringify(e.key)},\n`
        }
        typings += '  }\n\n'
        continue
      }

      if (struct.isArray) {
        const typeName = sanitize(struct.name)
        const elementType = tsType(struct.type, struct.namespace)
        typings += `  export type ${typeName} = ${elementType}[];\n\n`
        continue
      }

      if (struct.isStruct || struct.isVersioned) {
        const typeName = sanitize(struct.name)
        typings += `  export interface ${typeName} {\n`

        if (struct.isVersioned) typings += `    version?: number;\n`

        for (const field of struct.fields || []) {
          const name = field.name
          const optional = field.required ? '' : '?'
          const safeName = generateString(name)

          typings += `    ${safeName}${optional}: ${tsType(field.type, struct.namespace)};\n`
        }

        typings += '  }\n\n'
      }
    }

    typings += '}\n\n' // close namespace
  }

  // encode/decode overloads
  for (const [namespace, structs] of structsByNamespace.entries()) {
    const nsName = sanitize(namespace)

    for (const struct of structs) {
      if (!(struct.isStruct || struct.isEnum || struct.isArray)) continue

      const typeName = sanitize(struct.name)
      const fqn = `${nsName}.${typeName}`

      typings += `export function encode(name: "${fqn}", value: ${fqn}, v?: number): Uint8Array;\n`
      typings += `export function decode(name: "${fqn}", buffer: Uint8Array, v?: number): ${fqn};\n`
    }
  }

  typings += `
export function getEncoding(name: string): any;
export function getEnum(name: string): any;
export function getStruct(name: string, v?: number): any;
export function setVersion(v: number): void;
export const version: number;
`

  function tsType(type, currentNamespace) {
    if (!type) return 'any'

    if (type.isAlias) return tsType(type.type, currentNamespace)

    if (type.isPrimitive) {
      const t = type.name

      if (NumericTypes.has(t)) return 'number'
      if (BigIntTypes.has(t)) return 'bigint'
      if (BooleanTypes.has(t)) return 'boolean'
      if (StringTypes.has(t)) return 'string'
      if (NetworkTypes.has(t)) return 'string'
      if (t === 'json') return 'any'

      if (ObjectTypes.has(t)) {
        switch (t) {
          case 'buffer':
          case 'fixed32':
          case 'fixed64':
            return 'Uint8Array'
          case 'date':
            return 'Date'
        }
      }

      return 'any'
    }

    const targetNs = type.namespace || null
    const targetName = sanitize(type.name)

    if (!targetNs || targetNs === currentNamespace) {
      return targetName
    }

    return `${sanitize(targetNs)}.${targetName}`
  }

  function sanitize(name) {
    return name
      .replace(/[^a-zA-Z0-9_]/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join('')
  }

  return typings
}
