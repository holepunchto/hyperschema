const gen = require('generate-object-property')
const s = require('generate-string')

module.exports = function generateSchema (hyperschema) {
  const structs = []
  const structsByName = new Map()

  for (let i = 0; i < hyperschema.schema.length; i++) {
    const fqn = hyperschema.typesByPosition.get(i)
    const type = hyperschema.resolve(fqn)
    if (type.isStruct) {
      structs.push(type)
    }
  }

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const id = 'encoding' + i
    const encoder = generateStruct(id, struct)
    structsByName.set(struct.fqn, { encoder, id })
  }

  let str = ''
  str += '// This file is autogenerated by the hyperschema compiler\n'
  str += `// Schema Version: ${hyperschema.version}\n`
  str += '/* eslint-disable camelcase */\n'
  str += '/* eslint-disable quotes */\n'
  str += '\n'
  str += `const VERSION = ${hyperschema.version}\n`
  str += 'const { c } = require(\'hyperschema/runtime\')\n'
  str += '\n'
  str += '// eslint-disable-next-line no-unused-vars\n'
  str += 'let version = VERSION\n'
  str += '\n'

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const { encoder } = structsByName.get(struct.fqn)
    str += encoder
    str += '\n'
  }

  str += 'function getStructByName (name) {\n'
  str += '  switch (name) {\n'
  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    str += `    case ${s(struct.fqn)}: return ${structsByName.get(struct.fqn).id}\n`
  }
  str += '    default: throw new Error(\'Encoder not found \' + name)\n'
  str += '  }\n'
  str += '}\n'

  str += '\n'

  str += 'function resolveStruct (name, v = VERSION) {\n'
  str += '  const enc = getStructByName(name)\n'
  str += '  return {\n'
  str += '    preencode (state, m) {\n'
  str += '      version = v\n'
  str += '      enc.preencode(state, m)\n'
  str += '    },\n'
  str += '    encode (state, m) {\n'
  str += '      version = v\n'
  str += '      enc.encode(state, m)\n'
  str += '    },\n'
  str += '    decode (state) {\n'
  str += '      version = v\n'
  str += '      return enc.decode(state)\n'
  str += '    }\n'
  str += '  }\n'
  str += '}\n'
  str += '\n'
  str += 'module.exports = { resolveStruct, version }\n'

  return str

  function generateStruct (id, struct) {
    let str = ''
    const fieldTypes = new Map()

    for (let i = 0; i < struct.fields.length; i++) {
      const field = struct.fields[i]
      if (!field.framed && !field.array) continue

      let typeStr = ''
      if (field.type.isPrimitive) {
        typeStr = gen('c', field.type.name)
      } else if (field.type.isAlias) {
        typeStr = gen('c', field.type.type.name)
      } else {
        typeStr = structsByName.get(field.type.fqn).id
      }
      if (field.array) typeStr = `c.array(${typeStr})`
      if (field.framed) typeStr = `c.frame(${typeStr})`
      const fieldId = `${id}_${i}`
      fieldTypes.set(field.name, fieldId)

      str += `// ${struct.fqn}.${field.name}\n`
      str += `const ${fieldId} = ${typeStr}\n`
    }
    if (fieldTypes.size) {
      str += '\n'
    }

    const preencode = generateEncode(struct, { preencode: true })
    const encode = generateEncode(struct)
    const decode = generateDecode(struct)
    str += `// ${struct.fqn}\n`
    str += `const ${id} = {\n`
    str += '  preencode (state, m) {\n'
    str += `${preencode}\n`
    str += '  },\n'
    str += '  encode (state, m) {\n'
    str += `${encode}\n`
    str += '  },\n'
    str += '  decode (state) {\n'
    str += `${decode}\n`
    str += '  }\n'
    str += '}\n'
    return str

    function generateEncode (struct, { preencode = false } = {}) {
      const fn = preencode ? 'preencode' : 'encode'
      let str = ''

      if (struct.optionals.length >= 1) str += '    let flags = 0\n'
      for (const field of struct.optionals) {
        str += `    ${vPrefix(field.version, gen('m', field.name))} flags |= ${field.flag}`
        str += '\n'
      }
      if (struct.optionals.length >= 1) str += '\n'

      let bitfield = false
      let optional = false
      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        if (i === struct.flagsPosition) {
          str += `    c.uint.${fn}(state, flags)`
          bitfield = true
        }
        if (field.type.bool) continue

        if (bitfield === true) {
          str += '\n'
          bitfield = false
        }
        if (!field.required && !optional) {
          str += '\n'
          optional = true
        }

        let prefix = '   '
        if (!field.required) {
          prefix += ` ${vPrefix(field.version, gen('m', field.name))}`
        }

        str += `${prefix} ${getFieldEncoder(field)}.${fn}(state, ${gen('m', field.name)})`
        if (i !== struct.fields.length - 1) {
          let onlyBools = true
          for (let j = i + 1; j < struct.fields.length; j++) {
            const field = struct.fields[j]
            if (!field) break
            if (!field.type.bool) {
              onlyBools = false
              break
            }
          }
          if (!onlyBools) str += '\n'
        }
      }
      return str
    }

    function generateDecode (struct) {
      let str = ''

      str += '    const res = {}\n'
      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        str += `    ${vPrefix(field.version)}${gen('res', field.name)} = ${field.type.default}\n`
      }
      str += '\n'

      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        let decodeStr = ''
        if (field.type.bool) {
          decodeStr = `${gen('res', field.name)} = true`
        } else {
          decodeStr = `${gen('res', field.name)} = ${getFieldEncoder(field)}.decode(state)`
        }

        if (i === struct.flagsPosition) {
          if (i !== 0) str += '\n'
          str += '    const flags = state.start < state.end ? c.uint.decode(state) : 0\n'
        }

        if (field.required) {
          str += `    ${decodeStr}\n`
        } else {
          str += `    ${vPrefix(field.version, `(flags & ${field.flag}) !== 0`)} ${decodeStr}\n`
        }
      }

      if (struct.fields.length !== 0) str += '\n'
      str += '    return res'
      return str
    }

    function vPrefix (v, condition) {
      if (v === 1) return condition ? `if (${condition})` : ''
      return condition ? `if ((version >= ${v}) && ${condition})` : `if (version >= ${v}) `
    }

    function getFieldEncoder (field) {
      if (fieldTypes.has(field.name)) return fieldTypes.get(field.name)
      return getEncoder(field.type)
    }

    function getEncoder (type) {
      if (type.isAlias) return getEncoder(type.type)
      if (type.isPrimitive) return `c.${type.name}`
      return structsByName.get(type.fqn).id
    }
  }
}
