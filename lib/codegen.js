const gen = require('generate-object-property')
const s = require('generate-string')

module.exports = function generateSchema(
  hyperschema,
  { esm = false, filename } = {}
) {
  const structs = []
  const structsByName = new Map()
  const deferred = []
  const dedup = new Map()
  const externals = new Map()
  const inlining = new Set()

  for (let i = 0; i < hyperschema.schema.length; i++) {
    const fqn = hyperschema.typesByPosition.get(i)
    const type = hyperschema.resolve(fqn)
    if (type.isStruct) {
      structs.push(type)

      for (const f of type.fields) {
        if (f.inline) inlining.add(f.type.fqn)
      }
    }
    if (type.isArray) {
      structs.push(type)
    }
    if (type.isEnum) {
      structs.push(type)
    }
    if (type.isExternal) {
      structs.push(type)
    }
    if (type.isVersioned) {
      structs.push(type)
    }
  }

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const id = 'encoding' + i
    const result = { encoder: null, inlinedEncoder: null, id }
    structsByName.set(struct.fqn, result)
  }
  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const result = structsByName.get(struct.fqn)

    if (struct.isExternal) {
      const v = requireExternal(struct, filename)
      result.encoder = `const ${result.id} = ${gen(v, struct.external)}\n`
      continue
    }

    result.encoder = struct.isEnum
      ? generateEnum(result.id, struct)
      : struct.isVersioned
        ? generateVersioned(result.id, struct)
        : generateStruct(result.id, struct, deferred, false)

    if (inlining.has(struct.fqn)) {
      result.encoder += '\n' + generateStruct(result.id, struct, deferred, true)
    }
  }

  let str = ''

  str += '// This file is autogenerated by the hyperschema compiler\n'
  str += `// Schema Version: ${hyperschema.version}\n`
  str += '/* eslint-disable camelcase */\n'
  str += '/* eslint-disable quotes */\n'
  str += '/* eslint-disable space-before-function-paren */\n'
  str += '\n'

  if (esm) {
    str += "import { c } from 'hyperschema/runtime'\n"
  } else {
    str += "const { c } = require('hyperschema/runtime')\n"
  }
  for (const [req, v] of externals) {
    if (esm) {
      str += `import * as ${v} from ${s(req)}\n`
    } else {
      str += `const ${v} = require(${s(req)})\n`
    }
  }

  str += '\n'
  str += `const VERSION = ${hyperschema.version}\n`
  str += '\n'

  str += '// eslint-disable-next-line no-unused-vars\n'
  str += 'let version = VERSION\n'
  str += '\n'

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const { encoder } = structsByName.get(struct.fqn)
    str += encoder
    str += '\n'
  }

  if (deferred.length) {
    str += deferred.join('')
    str += '\n'
  }

  str += 'function setVersion(v) {\n'
  str += '  version = v\n'
  str += '}\n'
  str += '\n'

  str += 'function encode(name, value, v = VERSION) {\n'
  str += '  version = v\n'
  str += '  return c.encode(getEncoding(name), value)\n'
  str += '}\n'
  str += '\n'

  str += 'function decode(name, buffer, v = VERSION) {\n'
  str += '  version = v\n'
  str += '  return c.decode(getEncoding(name), buffer)\n'
  str += '}\n'
  str += '\n'

  str += 'function getEnum(name) {\n'
  str += '  switch (name) {\n'
  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    if (struct.enum) {
      str += `    case ${s(struct.fqn)}:\n`
      str += `      return ${structsByName.get(struct.fqn).id}_enum\n`
    }
  }
  str += '    default:\n'
  str += "      throw new Error('Enum not found ' + name)\n"
  str += '  }\n'
  str += '}\n'

  str += '\n'

  str += 'function getEncoding(name) {\n'
  str += '  switch (name) {\n'
  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    str += `    case ${s(struct.fqn)}:\n`
    str += `      return ${structsByName.get(struct.fqn).id}\n`
  }
  str += '    default:\n'
  str += "      throw new Error('Encoder not found ' + name)\n"
  str += '  }\n'
  str += '}\n'

  str += '\n'

  str += 'function getStruct(name, v = VERSION) {\n'
  str += '  const enc = getEncoding(name)\n'
  str += '  return {\n'
  str += '    preencode(state, m) {\n'
  str += '      version = v\n'
  str += '      enc.preencode(state, m)\n'
  str += '    },\n'
  str += '    encode(state, m) {\n'
  str += '      version = v\n'
  str += '      enc.encode(state, m)\n'
  str += '    },\n'
  str += '    decode(state) {\n'
  str += '      version = v\n'
  str += '      return enc.decode(state)\n'
  str += '    }\n'
  str += '  }\n'
  str += '}\n'
  str += '\n'
  str += 'const resolveStruct = getStruct // compat\n'
  str += '\n'

  if (esm) {
    str +=
      'export { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version }\n'
  } else {
    str +=
      'module.exports = {\n  resolveStruct,\n  getStruct,\n  getEnum,\n  getEncoding,\n  encode,\n  decode,\n  setVersion,\n  version\n}\n'
  }

  return str

  function requireExternal(struct, filename) {
    if (!filename)
      throw new Error('Must provide filename if using external types')
    const req = struct.require(filename)
    let v = externals.get(req)
    if (v) return v
    v = 'external' + externals.size
    externals.set(req, v)
    return v
  }

  function generateEnum(id, struct) {
    let str = ''

    str += `const ${id}_enum = {\n`

    for (let i = 0; i < struct.enum.length; i++) {
      const e = struct.enum[i]
      const value = struct.strings ? s(e.key) : i + struct.offset
      str += `  ${gen.property(e.key)}: ${value}${i < struct.enum.length - 1 ? ',' : ''}\n`
    }

    str += '}\n\n'

    const preencode = generateEncode({ preencode: true })
    const encode = generateEncode()
    const decode = generateDecode()

    str += `// ${struct.fqn} enum\n`
    str += `const ${id} = {\n`
    str += '  preencode (state, m) {\n'
    str += `${preencode}`
    str += '  },\n'
    str += '  encode (state, m) {\n'
    str += `${encode}`
    str += '  },\n'
    str += '  decode (state) {\n'
    str += `${decode}`
    str += '  }\n'
    str += '}\n'

    return str

    function generateEncode({ preencode = false } = {}) {
      const max = struct.enum.length + struct.offset - 1
      const encode = preencode ? 'preencode' : 'encode'

      if (preencode && max <= 0xfc) {
        return `    state.end++ // max enum is ${max} so always one byte\n`
      }

      if (!struct.strings) {
        let str = ''
        str += `    if (m > ${max}) throw new Error('Unknown enum')\n`
        str += `    c.uint.${encode}(state, m)\n`
        return str
      }

      let str = '    switch (m) {\n'
      for (let i = 0; i < struct.enum.length; i++) {
        str += `      case ${s(struct.enum[i].key)}:\n`
        str += `        c.uint.${encode}(state, ${i + struct.offset})\n`
        str += '        break\n'
      }
      str += '      default:\n'
      str += "        throw new Error('Unknown enum')\n"
      str += '    }\n'
      return str
    }

    function generateDecode() {
      if (!struct.strings) return '    return c.uint.decode(state)\n'

      let str = '    switch (c.uint.decode(state)) {\n'
      for (let i = 0; i < struct.enum.length; i++) {
        str += `      case ${i + struct.offset}:\n`
        str += `        return ${s(struct.enum[i].key)}\n`
      }
      str += '      default: return null\n'
      str += '    }\n'
      return str
    }
  }

  function getGeneratedTypeEncoder(type) {
    if (type.isPrimitive) {
      return gen('c', type.name)
    }

    if (type.isAlias) {
      return getGeneratedTypeEncoder(type.type)
    }

    return structsByName.get(type.fqn).id
  }

  function dedupConst(name, def, deferred = false) {
    if (dedup.has(def)) return `const ${name} = ${dedup.get(def).name}\n`
    dedup.set(def, { deferred, name })
    return `const ${name} = ${def}\n`
  }

  function getGeneratedFieldEncoder(field) {
    const typeStr = getGeneratedTypeEncoder(field.type)

    if (field.array) {
      if (field.framed) {
        return `c.array(c.frame(${typeStr}))`
      }
      return `c.array(${typeStr})`
    }

    if (field.framed) {
      return `c.frame(${typeStr})`
    }

    return typeStr
  }

  function generateVersioned(id, struct) {
    let str = ''
    let enc = ''

    str += `// ${struct.fqn}\n`
    str += ''

    const preencode = generateEncode({ preencode: true })
    const encode = generateEncode()
    const decode = generateDecode()

    enc += '{\n'
    enc += '  preencode(state, m) {\n'
    enc += `${preencode.trimRight()}\n`
    enc += '  },\n'
    enc += '  encode(state, m) {\n'
    enc += `${encode.trimRight()}\n`
    enc += '  },\n'
    enc += '  decode(state) {\n'
    enc += `${decode.trimRight()}\n`
    enc += '  }\n'
    enc += '}'

    str += dedupConst(id, enc)

    return str

    function generateEncode({ preencode = false } = {}) {
      const fn = preencode ? 'preencode' : 'encode'
      let str = ''
      str += `    c.uint.${fn}(state, m.version)\n`
      str += '    switch (m.version) {\n'
      let version = 0
      for (let i = 0; i < struct.versions.length; i++) {
        const def = struct.versions[i]
        while (version <= def.version) str += `      case ${version++}:\n`
        str += `        ${getEncoder(def.type)}.${fn}(state, m)\n`
        str += '        break\n'
      }
      str += '      default:\n'
      str += "        throw new Error('Unsupported version')\n"
      str += '    }'

      return str
    }

    function generateDecode() {
      let str = ''
      str += '    const version = c.uint.decode(state)\n'
      str += '    switch (version) {'
      let version = 0
      for (let i = 0; i < struct.versions.length; i++) {
        const def = struct.versions[i]
        while (version <= def.version) str += `\n      case ${version++}:`
        str += ' {\n'
        str += `        const decoded = ${getEncoder(def.type)}.decode(state, version)\n`
        if (def.map) {
          const v = requireExternal(struct, filename)
          str += `        const map = ${gen(v, def.map)}\n`
          str += '        return map(decoded)\n'
        } else {
          str += '        return decoded\n'
        }
        str += '      }'
      }
      str += '\n      default:\n'
      str += "        throw new Error('Unsupported version')\n"
      str += '    }'

      return str
    }

    function getEncoder(type) {
      if (type.isAlias) return getEncoder(type.type)
      if (type.isPrimitive) return `c.${type.name}`
      return structsByName.get(type.fqn).id
    }
  }

  function generateStruct(id, struct, deferred, inlinable) {
    const fieldTypes = new Map()

    if (inlinable) id += '_inline'

    const inlines = {
      uint: null,
      fields: new Map()
    }

    for (const field of struct.fields) {
      if (!field.inline) continue
      if (!field.type.isStruct) continue

      const entry = []

      for (const f of field.type.fields) {
        if (f.required) continue
        entry.push({
          field: f,
          flag: 0
        })
      }

      if (entry.length) {
        inlines.fields.set(field, entry)
      }
    }

    let str = ''
    let enc = ''

    if (struct.isArray) {
      enc = getGeneratedTypeEncoder(struct.type)
    } else {
      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        if (!field.framed && !field.array) continue

        const fieldId = `${id}_${i}`
        fieldTypes.set(field.name, fieldId)

        const fieldEnc = getGeneratedFieldEncoder(field)
        const isDeferred = !!dedup.get(fieldEnc)?.deferred

        // if recursive, defer the field type
        if (structsByName.get(field.type.fqn)?.encoder === null || isDeferred) {
          let d = ''
          d += `// ${struct.fqn}.${field.name}, deferred due to recusive use\n`
          d += dedupConst(fieldId, fieldEnc, true)
          deferred.push(d)
        } else {
          str += `// ${struct.fqn}.${field.name}\n`
          str += dedupConst(fieldId, fieldEnc, false)
        }
      }

      if (str) {
        str += '\n'
      }

      const preencode = generateEncode({ preencode: true })
      const encode = generateEncode()
      const decode = generateDecode()
      const needsVersion = struct.expectsVersion

      enc += '{\n'
      enc += `  preencode(state, m) {\n`
      enc += `${preencode.trimRight()}\n`
      enc += '  },\n'
      enc += `  encode(state, m) {\n`
      enc += `${encode.trimRight()}\n`
      enc += '  },\n'
      enc += `  decode(state${inlinable ? ', inlining' : ''}${needsVersion ? ', version' : ''}) {\n`
      enc += `${decode.trimRight()}\n`
      enc += '  }\n'
      enc += '}'
    }

    str += `// ${struct.fqn}${inlinable ? ' (inline)' : ''}\n`

    if (struct.isArray) {
      if (struct.framed) {
        str += dedupConst(id, `c.array(c.frame(${enc}))`)
      } else {
        str += dedupConst(id, `c.array(${enc})`)
      }
    } else {
      str += dedupConst(id, enc)
    }

    return str

    function generateEncode({ preencode = false } = {}) {
      const fn = preencode ? 'preencode' : 'encode'
      let str = ''
      let maxFlag = 0
      let fastFlags = false

      const flags = []
      for (let i = 0; i < struct.optionals.length; i++) {
        const field = struct.optionals[i]

        maxFlag = Math.max(maxFlag, field.flag)
        if (field.external) continue
        flags.push(generateFlag(field))
      }

      for (const props of inlines.fields.values()) {
        for (const p of props) {
          maxFlag *= 2
          p.flag = maxFlag
        }
      }

      if (flags.length || inlines.fields.size) {
        if (flags.length === 0) flags.push('(0)')

        const mut = inlines.fields.size ? 'let' : 'const'

        if (maxFlag < 128 && preencode) {
          fastFlags = true
        } else if (!inlinable) {
          str += combineFlags('    ', mut, '=', flags)

          for (const [field, props] of inlines.fields) {
            const parent = gen('m', field.name)
            str += `    if (${parent}) {\n`
            const flags = props.map((p) => generateFlag(p.field, parent, p.flag))
            str += `${combineFlags('      ', '', '|=', flags)}`
            str += '    }'
          }

          str += '\n'
        }
      }

      let bitfield = false
      let optional = false

      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        if (field.external) continue

        if (i === struct.flagsPosition && !inlinable) {
          if (fastFlags) {
            str += `    state.end++ // max flag is ${maxFlag} so always one byte`
          } else {
            str += `    c.uint.${fn}(state, flags)`
          }
          bitfield = true
        }
        if (field.type.bool) continue

        if (bitfield === true) {
          str += '\n'
          bitfield = false
        }
        if (!field.required && !optional) {
          str += '\n'
          optional = true
        }

        let prefix = '   '
        if (!field.required) {
          prefix += ` ${vPrefix(field.version, gen('m', field.name))}`
        }

        const suffix = inlines.fields.has(field) ? '_inline' : ''
        const encoder = `${getFieldEncoder(field)}${suffix}.${fn}(state, ${gen('m', field.name)})`

        str += `${prefix} ${encoder}`

        if (i !== struct.fields.length - 1) {
          let onlyBools = true
          for (let j = i + 1; j < struct.fields.length; j++) {
            const field = struct.fields[j]
            if (!field) break
            if (!field.type.bool) {
              onlyBools = false
              break
            }
          }
          if (!onlyBools || !bitfield) str += '\n'
        }
      }

      for (let i = 0; i < str.length; i++) {
        if (str[i] !== '\n') {
          str = str.slice(i)
          break
        }
      }

      return str
    }

    function generateDecode() {
      let str = ''
      let seen = 0

      if (struct.expectsVersion) {
        str += '    if (version === undefined) version = c.uint.decode(state)\n'
      }

      const pre = new Map()
      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        if (
          !field.required ||
          field.type.bool ||
          i === struct.flagsPosition ||
          field.inline
        ) {
          break
        }
        seen++
        if (field.external) continue
        pre.set(field, 'r' + i)
        str += `    const r${i} = ${getFieldEncoder(field)}.decode(state)\n`
      }

      if (seen === struct.flagsPosition) {
        if (inlinable) {
          str += '    const flags = inlining\n\n'
        } else if (alwaysOptional(struct)) {
          str += `    const flags = c.uint.decode(state)\n\n`
        } else {
          str += `    const flags = state.start < state.end ? c.uint.decode(state) : 0\n\n`
        }
      } else if (pre.size) {
        str += '\n'
      }

      str += '    return {\n'
      if (struct.expectsVersion) str += '      version,\n'

      for (let i = 0; i < struct.fields.length; i++) {
        const field = struct.fields[i]
        const end = i < struct.fields.length - 1 ? ',\n' : '\n'
        const flag = vInlinePrefix(
          field.version,
          `(flags & ${field.flag}) !== 0`
        )
        const prop = gen.property(field.name)

        let shift = ''
        if (field.inline) {
          const { flag } = inlines.fields.get(field)[0]
          shift = `, flags >>> ${Math.log2(flag)}`
        }

        const suffix = field.inline ? '_inline' : ''

        const decoder = `${getFieldEncoder(field)}${suffix}.decode(state${shift})`

        if (field.external) {
          str += `      ${prop}: ${field.getDefaultValue()}${end}`
          continue
        }

        if (pre.has(field)) {
          str += `      ${prop}: ${pre.get(field)}${end}`
          continue
        }

        if (field.type.bool) {
          str += `      ${prop}: ${flag}${end}`
          continue
        }
        if (field.required) {
          str += `      ${prop}: ${decoder}${end}`
          continue
        }

        str += `      ${prop}: ${flag} ? ${decoder} : ${field.getDefaultValue()}${end}`
      }

      str += '    }'

      return str
    }

    function vPrefix(v, condition) {
      if (v === 1) return condition ? `if (${condition})` : ''
      return condition
        ? `if (version >= ${v} && ${condition})`
        : `if (version >= ${v}) `
    }

    function vInlinePrefix(v, condition) {
      if (v === 1) return condition || ''
      return condition ? `(version >= ${v} && ${condition})` : `version >= ${v}`
    }

    function generateFlag(field, parent = 'm', flag = field.flag) {
      return `(${vInlinePrefix(field.version, gen(parent, field.name))} ? ${flag} : 0)`
    }

    function combineFlags(indent, mut, op, flags) {
      if (mut) mut += ' '

      let s = `${indent}${mut}flags ${op}`

      if (flags.length === 1) {
        flags = flags.slice(0)
        flags[0] = flags[0].slice(1, -1)
      }

      const inline = flags.join(' | ')
      if (s.length + inline.length + 1 <= 100) return s + ' ' + inline + '\n'

      s += '\n'
      for (let i = 0; i < flags.length; i++) {
        s += indent + '  ' + flags[i] + (i < flags.length - 1 ? ' |\n' : '\n')
      }

      return s
    }

    function getFieldEncoder(field) {
      if (fieldTypes.has(field.name)) return fieldTypes.get(field.name)
      return getEncoder(field.type)
    }

    function getEncoder(type) {
      if (type.isAlias) return getEncoder(type.type)
      if (type.isPrimitive) return `c.${type.name}`
      return structsByName.get(type.fqn).id
    }
  }
}

function alwaysOptional(struct) {
  for (let i = 0; i < struct.fields.length; i++) {
    const f = struct.fields[i]
    if (f.required) continue

    for (let j = 0; j < i; j++) {
      const p = struct.fields[j]
      if (p.version !== f.version) return false
    }

    return true
  }

  return false
}
