const gen = require('generate-object-property')
const s = require('generate-string')

module.exports = function generateSchema(
  hyperschema,
  { filename, package = 'schema' } = {}
) {
  const structs = []
  const structsByName = new Map()
  const setupTypes = new Map()
  setupTypes.set('uint', {
    value: 'uint: cenc.NewUint()',
    def: 'uint *cenc.Uint',
    type: 'uint'
  })

  for (let i = 0; i < hyperschema.schema.length; i++) {
    const fqn = hyperschema.typesByPosition.get(i)
    const type = hyperschema.resolve(fqn)
    if (type.isStruct) {
      structs.push(type)
    }
    if (type.isArray) {
      structs.push(type)
    }
    if (type.isEnum) {
      structs.push(type)
    }
    if (type.isExternal) {
      structs.push(type)
    }
    if (type.isVersioned) {
      structs.push(type)
    }
  }

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    const id = 'Encoding' + i
    const result = { encoder: null, id }
    structsByName.set(struct.fqn, result)
  }

  let str = ''

  str += '// This file is autogenerated by the hyperschema compiler\n'
  str += `// Schema Version: ${hyperschema.version}\n`
  str += '\n'
  str += `package ${package}

  import (
	cenc "github.com/holepunchto/compact-encoding-golang"
  )
  `

  // TODO
  // str += '\n'
  // str += `const VERSION = ${hyperschema.version}\n`
  // str += '\n'
  // str += 'var version = VERSION\n'
  // str += '\n'

  // setup types to allow reuse
  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]
    gatherTypes(struct)
  }

  str += `type Encoding struct {
	${getTypesStruct()}
  }

  var c = &Encoding{
	${initTypes()}
  }
  `

  for (let i = 0; i < structs.length; i++) {
    const struct = structs[i]

    str += toGoStruct(struct, setupTypes)
    str += '\n'
  }

  return str

  function getTypesStruct() {
    let str = ''
    for (const { def } of setupTypes.values()) {
      str += def
      str += '\n'
    }
    return str
  }
  function initTypes() {
    let str = ''
    for (const { value } of setupTypes.values()) {
      str += value
      str += ',\n'
    }
    return str
  }

  function gatherTypes(struct) {
    for (const { type, array } of struct.fields) {
      if (!type.isPrimitive) {
        // TOOD
        continue
      }

      if (array) {
        switch (type.name) {
          case 'string': {
            setupTypes.set(`strings`, {
              value: 'strings: 	cenc.NewArray(cenc.NewString())',
              def: 'strings *cenc.Array[string]',
              type: 'string'
            })
            break
          }
          case 'int': {
            setupTypes.set(`ints`, {
              value: 'ints: 	cenc.NewArray(cenc.NewInt())',
              def: 'ints *cenc.Array[int]',
              type: 'int'
            })
            break
          }
          case 'bool': {
            setupTypes.set(`bools`, {
              value: 'bools: 	cenc.NewArray(cenc.NewBool())',
              def: 'bools *cenc.Array[bool]',
              type: 'bool'
            })
            break
          }
        }
      } else {
        switch (type.name) {
          case 'string': {
            setupTypes.set('string', {
              value: 'string: cenc.NewString()',
              def: 'string *cenc.String',
              type: 'string'
            })
            break
          }
          case 'int': {
            setupTypes.set('int', {
              value: 'int: cenc.NewInt()',
              def: 'int *cenc.Int',
              type: 'int'
            })
            break
          }
          case 'bool': {
            setupTypes.set('bool', {
              value: 'bool: cenc.NewBool()',
              def: 'bool *cenc.Bool',
              type: 'bool'
            })
            break
          }
        }
      }
    }
  }
}

function toGoStruct(struct, setupTypes) {
  const name = fqnToName(struct.fqn)

  let str = `
type ${name} struct {
${buildStruct(struct, setupTypes)}
}

func (m *${name}) Preencode(state *cenc.State) {
${preencode(struct)}
}

func (m *${name}) Encode(state *cenc.State) error {
${encode(struct)}

return nil
}

func (m *${name}) Decode(state *cenc.State) error {
var err error

${decode(struct)}

return nil
}`
  return str
}

function buildStruct(struct, setupTypes) {
  let str = ''
  for (const f of struct.fields) {
    const { name, type, array } = f
    str += toPublic(name)
    str += ' '
    if (array) {
      str += '[]'
    }
    console.log(array, `${type.name}${array ? 's' : ''}`)
    str += setupTypes.get(`${type.name}${array ? 's' : ''}`).type

    str += '\n'
  }
  return str
}

function preencode(struct) {
  let str = ''
  for (const { name, type, array } of struct.fields) {
    str += 'c.'
    str += type.name
    if (array) {
      str += 's'
    }
    str += `.Preencode(state, m.${toPublic(name)})`

    str += '\n'
  }
  return str
}

function encode(struct) {
  let str = ''
  for (const { name, type, array } of struct.fields) {
    str += `if err := c.${type.name}${array ? 's' : ''}.Encode(state, m.${toPublic(name)}); err != nil {`
    str += '\nreturn err\n}'
    str += '\n'
  }
  return str
}

function decode(struct) {
  let str = ''
  for (const { name, type, array } of struct.fields) {
    str += `if m.${toPublic(name)}, err = c.${type.name}${array ? 's' : ''}.Decode(state); err != nil {`
    str += '\nreturn err\n}'
    str += '\n'
  }
  return str
}

function toPublic(name) {
  return name.slice(0, 1).toUpperCase() + name.slice(1)
}

function fqnToName(fqn) {
  let str = ''
  let nextUpper = true
  for (let i = 0; i < fqn.length; i++) {
    let char = fqn.charAt(i)
    if (char === '@') continue
    if (nextUpper) {
      char = char.toUpperCase()
      nextUpper = false
    } else if (['-', '/', '_'].includes(char)) {
      nextUpper = true
      continue
    }

    str += char
  }
  return str
}
